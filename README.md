# CS-300-DSA-Analysis-Design-Porfolio
Create a new repository for my DSA Portfolio.  Adding my instructor, Mike Susalla as a collaborator. 

What was the problem you were solving in the projects for this course?
Develop a program for the Computer Science department at ABCU. The program will need to load a CSV of department course numbers, titles and required prerequisites. It will need to print out the entire course catalog alphetically.  In addition, the program will need to be able to search for a course and print out the course and the required prerquisites for the course.

How did you approach the problem? Consider why data structures are important to understand.
The approach was to break the project down and analyze/compare three different data structure's time and space complexity for the best approach for the advisors needs.  It is important to consider the advantages and disadvantages of how each one of the data structures; vectors, hash-tables, and binary search trees would be the best overall approach for the advisors needs.  

How did you overcome any roadblocks you encountered while going through the activities or project?
To overcome the roadblocks in each milestone and project, I really had to stop and take 2-3 steps back with the assignments.  There was a lot of information to sort through.  I found that even before attempting to write out pseudocode, I needed to just write out a generic outline in full English sentences of what was expected and needed.  Then I refined that outline.  Then repeated this approach with actual pseudocode with one function at a time.  It takes practice to find a balance between an English outline for a term paper and actual code.

How has your work on this project expanded your approach to designing software and developing programs?
Working on this project taught me there is more than one approach for a solution.  It is easy to debate over which data structure or code language is better or faster for an application, but it really comes down to what works best for the customer's needs.  What do they actually want to do?  What do they actually need to do?  What features or functions are most important?  What compromises will need to be made in order to find the "best" solutioh.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
In short, break down projects into smaller pieces and then analyze, compare and decide which approach is best for who will be using the programs.  
